//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

#region GridState
/// <summary>
/// GridState - State in the search space containing total cost and position
/// 
/// Requires a Hash to be identified in the explored list
/// Requires a Cost for aggregating total weights along a path
/// Requires a Heuristic for estimating how close we are
/// 
/// </summary>
class GridState : IComparable<GridState>
{
	#region DataMembers
	////////////////
	/// Data Members
	///

	// Reference to world
	protected GridMap grid;

	// Previous pointer
	protected GridState previous;

	// State progress and goal
	protected GridPoint location;
	protected GridPoint destination;

	// Cached values
	protected int hash;
	protected double cost;
	protected double heuristic;
	#endregion
	
	#region GettersSetters
	/////////////////////
	/// Getters & Setters
	///
	public GridState Previous
	{
		get { return previous; }
	}

	public GridMap Grid
	{
		get { return grid; }
	}

	public GridPoint Location
	{
		get { return location; }
	}
	
	public GridPoint Destination
	{
		get { return destination; }
	}

	public int Hash
	{
		get { return hash; }
	}

	public double Cost
	{
		get { return cost; }
	}
	
	public double Heuristic
	{
		get { return heuristic; }
	}

	public List<GridState> Expand
	{
		get {
			List<GridState> ret = new List<GridState>();
			List<GridPoint> nadj = grid.GetAvailableAdjacentPoints(Location, Facing);
			foreach (GridPoint nLocation in nadj)
			{
				ret.Add(new GridState(grid, this, nLocation, destination));
			}
			return ret;
		}
	}

	public int CompareTo(GridState other)
	{
		if (other == null) return 1;
		
		return (Cost + Heuristic).CompareTo((other.Cost + other.Heuristic));
	}
	#endregion

	#region Constructors
	/////////////////
	/// Constructors
	///
	public GridState(GridMap grid, GridState previous, GridPoint location, GridPoint destination)
	{
		this.grid = grid;
		this.previous = previous;
		this.location = location;
		this.destination = destination;
		this.hash = computeHash();
		this.cost = computeCost();
		this.heuristic = computeHeuristic();
	}
	#endregion
	
	#region PrivateMembers
	///////////////////
	/// Private Members
	///

	private int computeHash()
	{
		return location.X * grid.Width + location.Z;
	}

	private double computeCost()
	{
		double initialCost = 0.0;
		if (Previous != null)
			initialCost = Previous.Cost;
		double transitionCost = costFunction();
		return initialCost + transitionCost;
	}

	private double computeHeuristic()
	{
		double dx = System.Math.Abs(location.X - destination.X);
		double dy = System.Math.Abs(location.Z - destination.Z);
		double dm = System.Math.Abs(dy - dx);
		double dn = 1 * (System.Math.Max(dx, dy) - dm);
		return dm + System.Math.Sqrt(2) * dn;
	}

	public Direction Facing
	{
		get {
			if (Previous == null) return Direction.DIRECTION_NONE;
			GridPoint p = previous.Location;
			GridPoint q = Location;
			
			if (p.X < q.X)
			{
				if (p.Z < q.Z)
					return Direction.DIRECTION_NORTHEAST;
				else if (p.Z > q.Z)
					return Direction.DIRECTION_SOUTHEAST;
				else
					return Direction.DIRECTION_EAST;
			}
			else if (p.X > q.X)
			{
				if (p.Z < q.Z)
					return Direction.DIRECTION_NORTHWEST;
				else if (p.Z > q.Z)
					return Direction.DIRECTION_SOUTHWEST;
				else
					return Direction.DIRECTION_WEST;
			}
			else
			{
				if (p.Z < q.Z)
					return Direction.DIRECTION_NORTH;
				else if (p.Z > q.Z)
					return Direction.DIRECTION_SOUTH;
				else
					return Direction.DIRECTION_NONE;
			}
		}
	}

	private double costFunction()
	{
		switch (Facing)
		{		
		case Direction.DIRECTION_NONE: return 0.0;
		case Direction.DIRECTION_NORTHWEST: return System.Math.Sqrt(2.0);
		case Direction.DIRECTION_NORTH: return 1.0;
		case Direction.DIRECTION_NORTHEAST: return System.Math.Sqrt(2.0);
		case Direction.DIRECTION_EAST: return 1.0;
		case Direction.DIRECTION_SOUTHEAST: return System.Math.Sqrt(2.0);
		case Direction.DIRECTION_SOUTH: return 1.0;
		case Direction.DIRECTION_SOUTHWEST: return System.Math.Sqrt(2.0);
		case Direction.DIRECTION_WEST: return 1.0;
		}
		return 0.0;
	}
	#endregion
}
#endregion

#region GridSearch
/////////////////////////////////////////
/// Base Class for Grid Search algorithms
///
class GridSearch
{
	#region BaseMembers
	////////////////
	/// Base Members
	///
	protected GridMap grid;
	#endregion
	
	#region GettersSetters
	/////////////////////
	/// Getters & Setters
	///
	public GridMap Grid
	{
		get { return grid; }
	}
	#endregion

	#region BaseConstructor
	/////////////////////
	/// Base Constructors
	///
	public GridSearch(GridMap grid)
	{
		this.grid = grid;
	}
	#endregion
}
#endregion
