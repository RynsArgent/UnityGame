//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

#region PriorityQueue
/// <summary>
/// PriorityQueue Class:
/// Implements a simple templatized priority queue using
/// a heap data structure. The values are organized in a List with
/// helper integer arithmetic indexing functions to access relatives.
/// 
/// The basic requirement is that the template value must extend IComparable
/// to guarantee that the smallest value is always at the first index
/// </summary>
class PriorityQueue<T> where T: IComparable<T>
{
	#region DataMembers
	////////////////
	/// Base Members
	///
	private List<T> v;
	#endregion
	
	#region GettersSetters
	/////////////////////
	/// Getters & Setters
	///
	public List<T> VList
	{
		get { return v; }
	}
	#endregion
	
	#region Constructors
	////////////////
	/// Constructors
	///
	public PriorityQueue()
	{
		v = new List<T>();
	}
	#endregion

	#region MainInterface
	/////////////////////
	/// Main Interface
	///

	// Adds an element to the priority queue and
	// shifts the value to the root if it is 
	// always lower than its parent
	public void Add(T value)
	{
		v.Add(value);
		percolateUp (v.Count - 1);
	}

	// Returns true if no elements are in the list
	public bool IsEmpty()
	{
		return v.Count <= 0;
	}

	// Returns the smallest value from the list
	public T Peek()
	{
		if (IsEmpty()) return default(T);
		return v[0];
	}
	
	// Removes the smallest value from the list
	// This is done by replacing the smallest value
	// with the last element and then re-adjusting
	// the heap by shifting the last element back down
	public void Remove()
	{
		if (IsEmpty()) return;
		v[0] = v[v.Count - 1];
		v.RemoveAt(v.Count - 1);
		percolateDown (0);
	}

	// Empties the Priority Queue
	public void Clear()
	{
		v.Clear();
	}
	#endregion

	#region PrivateHelpers
	///////////////////
	/// Private Helpers
	///

	// Swaps two values at the given indices in the list
	private void swap(int ind1, int ind2)
	{
		T temp = v[ind1];
		v[ind1] = v[ind2];
		v[ind2] = temp;
	}

	// Returns the index of the left child given the parent index
	private int getLeftChild(int ind)
	{
		return 2 * ind + 1;	
	}
	
	// Returns the index of the right child given the parent index
	private int getRightChild(int ind)
	{
		return 2 * ind + 2;
	}
	
	// Returns the index of the parent of the given child index
	private int getParent(int ind)
	{
		return (ind + 1) / 2 - 1;
	}

	// Starting at the provided index, shift the value up by
	// swapping the value with its parent as long as its value
	// is always lower than its parent.
	private void percolateUp(int ind)
	{
		int cur = ind;
		int par = getParent (cur);
		while (cur > 0 && v[cur].CompareTo(v[par]) < 0)
		{
			swap (cur, par);
			cur = par;
			par = getParent (cur);
		}
	}

	// Starting at the provided index, shift the value down
	// selecting the lowest left/right child index to shift with.
	// If the left/right child is not less than the value, we stop.
	private void percolateDown(int ind)
	{
		if (ind >= v.Count) return;
		int cur = ind;
		int check = ind;
		do
		{
			cur = check;
			int left = getLeftChild(cur);
			int right = getRightChild(cur);
			if (left < v.Count && v[left].CompareTo(v[check]) < 0)
				check = left;
			if (right < v.Count && v[right].CompareTo(v[check]) < 0)
				check = right;
			swap (cur, check);
		} while (check != cur);
	}
	#endregion
}
#endregion

